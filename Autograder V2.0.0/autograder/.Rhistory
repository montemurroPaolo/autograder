submission     <- run_submission$run_env
run_solution   <- run_code(solution_name)# Run the solution in a separate environment and save it
solution       <- run_solution$run_env
grade <- function(csv=TRUE,txt=FALSE,json=FALSE,normalize=TRUE,show_test=TRUE){
# Determine the tests
all_tests      <- parse_config(file_name = config_name, normalize=normalize)
# Assess the results of the tests
all_tests_res  <- do_assessment(all_tests, ass_title)
# Create feedback
feedback <- create_feedback(all_tests_res, csv=csv, txt=txt, json=json)
return(feedback)
}
grade()
weights[n_tests] - sum(weights) +100
weights
weights <- score_vec/sum(score_vec) *100
weights
# Points must sum up to 100 (normalization)
weights <- round(score_vec/sum(score_vec) *100.1)
weights
# Points must sum up to 100 (normalization)
weights <- round(score_vec/sum(score_vec) *100,1)
weights
sum(weights)!=100)
(sum(weights)!=100)
weights[n_tests] <- weights[n_tests] - sum(weights) +100
weights[n_tests]
library(shiny)
# Define UI for data upload app ----
ui <- fluidPage(
titlePanel("Welcome to Autograder 2.0"),
sidebarLayout(
sidebarPanel(
fileInput("file_uploaded", "Upload your submission", multiple = FALSE),
actionButton("do_grading",label = "Grade")
),
# Main panel for displaying outputs ----
mainPanel(
textOutput("execution_time"),
textOutput("execution"),
tableOutput("result"),
textOutput("total_score")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
uploaded_file <- "impossiblefile"
# Load the file and copy it in the submission folder
Reactive_Var <- eventReactive(input$file_uploaded, {
uploaded_file <- paste0("..",.Platform$file.sep,"submission",.Platform$file.sep, input$file_uploaded$name) # Remember the name!!!
file.copy(input$file_uploaded$datapath, uploaded_file )
return(uploaded_file)
}) # difference between reactive and observe: https://stackoverflow.com/questions/53016404/advantages-of-reactive-vs-observe-vs-observeevent
observeEvent(input$do_grading,{
uploaded_file <- Reactive_Var()
# If the file is copied correctly
if(file.exists(uploaded_file)){
start     <- Sys.time()
source("grader.R")
grade()
execution_time <- paste0(round(Sys.time() - start,4)," seconds")
# create grade report (like a function...)
grade_report <- eventReactive(input$do_grading, { return(TRUE) })
if(grade_report()){ # If we pressed grade
output$execution_time <- renderText(paste0("Execution time:" , execution_time))
output$execution      <- renderText(paste("Execution errors:", run_submission$run_error_feedback))
output$result         <- renderTable(grade(csv=TRUE,txt=FALSE,json=FALSE,normalize=TRUE,show_test=TRUE))
}
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
library(shiny)
# Define UI for data upload app ----
ui <- fluidPage(
titlePanel("Welcome to Autograder 2.0"),
sidebarLayout(
sidebarPanel(
fileInput("file_uploaded", "Upload your submission", multiple = FALSE),
actionButton("do_grading",label = "Grade")
),
# Main panel for displaying outputs ----
mainPanel(
textOutput("execution_time"),
textOutput("execution"),
tableOutput("result"),
textOutput("total_score")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
uploaded_file <- "impossiblefile"
# Load the file and copy it in the submission folder
Reactive_Var <- eventReactive(input$file_uploaded, {
uploaded_file <- paste0("..",.Platform$file.sep,"submission",.Platform$file.sep, input$file_uploaded$name) # Remember the name!!!
file.copy(input$file_uploaded$datapath, uploaded_file )
return(uploaded_file)
}) # difference between reactive and observe: https://stackoverflow.com/questions/53016404/advantages-of-reactive-vs-observe-vs-observeevent
observeEvent(input$do_grading,{
uploaded_file <- Reactive_Var()
# If the file is copied correctly
if(file.exists(uploaded_file)){
start     <- Sys.time()
source("grader.R")
grade()
execution_time <- paste0(round(Sys.time() - start,4)," seconds")
# create grade report (like a function...)
grade_report <- eventReactive(input$do_grading, { return(TRUE) })
if(grade_report()){ # If we pressed grade
output$execution_time <- renderText(paste0("Execution time:" , execution_time))
output$execution      <- renderText(paste("Execution errors:", run_submission$run_error_feedback))
output$result         <- renderTable(grade(csv=TRUE,txt=FALSE,json=FALSE,normalize=TRUE,show_test=TRUE))
}
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
round(score_vec/sum(score_vec) *100,1)
# Parse txt file
list_of_config <- load_text(file_name)
tests    <- list_of_config[["no_comment_text"]]
function (file, header = FALSE, sep = "", quote = "\"'", dec = ".",
numerals = c("allow.loss", "warn.loss", "no.loss"), row.names,
col.names, as.is = !stringsAsFactors, na.strings = "NA",
colClasses = NA, nrows = -1, skip = 0, check.names = TRUE,
fill = !blank.lines.skip, strip.white = FALSE, blank.lines.skip = TRUE,
comment.char = "#", allowEscapes = FALSE, flush = FALSE,
stringsAsFactors = default.stringsAsFactors(), fileEncoding = "",
encoding = "unknown", text, skipNul = FALSE)
{
if (missing(file) && !missing(text)) {
file <- textConnection(text, encoding = "UTF-8")
encoding <- "UTF-8"
on.exit(close(file))
}
if (is.character(file)) {
file <- if (nzchar(fileEncoding))
file(file, "rt", encoding = fileEncoding)
else file(file, "rt")
on.exit(close(file))
}
if (!inherits(file, "connection"))
stop("'file' must be a character string or connection")
if (!isOpen(file, "rt")) {
open(file, "rt")
on.exit(close(file))
}
pbEncoding <- if (encoding %in% c("", "bytes", "UTF-8"))
encoding
else "bytes"
numerals <- match.arg(numerals)
if (skip > 0L)
readLines(file, skip)
nlines <- n0lines <- if (nrows < 0L)
5
else min(5L, (header + nrows))
lines <- .External(C_readtablehead, file, nlines, comment.char,
blank.lines.skip, quote, sep, skipNul)
if (encoding %in% c("UTF-8", "latin1"))
Encoding(lines) <- encoding
nlines <- length(lines)
if (!nlines) {
if (missing(col.names))
stop("no lines available in input")
rlabp <- FALSE
cols <- length(col.names)
}
else {
if (all(!nzchar(lines)))
stop("empty beginning of file")
if (nlines < n0lines && file == 0L) {
pushBack(c(lines, lines, ""), file, encoding = pbEncoding)
on.exit((clearPushBack(stdin())))
}
else pushBack(c(lines, lines), file, encoding = pbEncoding)
first <- scan(file, what = "", sep = sep, quote = quote,
nlines = 1, quiet = TRUE, skip = 0, strip.white = TRUE,
blank.lines.skip = blank.lines.skip, comment.char = comment.char,
allowEscapes = allowEscapes, encoding = encoding,
skipNul = skipNul)
col1 <- if (missing(col.names))
length(first)
else length(col.names)
col <- numeric(nlines - 1L)
if (nlines > 1L)
for (i in seq_along(col)) col[i] <- length(scan(file,
what = "", sep = sep, quote = quote, nlines = 1,
quiet = TRUE, skip = 0, strip.white = strip.white,
blank.lines.skip = blank.lines.skip, comment.char = comment.char,
allowEscapes = allowEscapes, encoding = encoding,
skipNul = skipNul))
cols <- max(col1, col)
rlabp <- (cols - col1) == 1L
if (rlabp && missing(header))
header <- TRUE
if (!header)
rlabp <- FALSE
if (header) {
.External(C_readtablehead, file, 1L, comment.char,
blank.lines.skip, quote, sep, skipNul)
if (missing(col.names))
col.names <- first
else if (length(first) != length(col.names))
warning("header and 'col.names' are of different lengths")
}
else if (missing(col.names))
col.names <- paste0("V", 1L:cols)
if (length(col.names) + rlabp < cols)
stop("more columns than column names")
if (fill && length(col.names) > cols)
cols <- length(col.names)
if (!fill && cols > 0L && length(col.names) > cols)
stop("more column names than columns")
if (cols == 0L)
stop("first five rows are empty: giving up")
}
if (check.names)
col.names <- make.names(col.names, unique = TRUE)
if (rlabp)
col.names <- c("row.names", col.names)
nmColClasses <- names(colClasses)
if (is.null(nmColClasses)) {
if (length(colClasses) < cols)
colClasses <- rep_len(colClasses, cols)
}
else {
tmp <- rep_len(NA_character_, cols)
names(tmp) <- col.names
i <- match(nmColClasses, col.names, 0L)
if (any(i <= 0L))
warning("not all columns named in 'colClasses' exist")
tmp[i[i > 0L]] <- colClasses[i > 0L]
colClasses <- tmp
}
what <- rep.int(list(""), cols)
names(what) <- col.names
colClasses[colClasses %in% c("real", "double")] <- "numeric"
known <- colClasses %in% c("logical", "integer", "numeric",
"complex", "character", "raw")
what[known] <- sapply(colClasses[known], do.call, list(0))
what[colClasses %in% "NULL"] <- list(NULL)
keep <- !sapply(what, is.null)
data <- scan(file = file, what = what, sep = sep, quote = quote,
dec = dec, nmax = nrows, skip = 0, na.strings = na.strings,
quiet = TRUE, fill = fill, strip.white = strip.white,
blank.lines.skip = blank.lines.skip, multi.line = FALSE,
comment.char = comment.char, allowEscapes = allowEscapes,
flush = flush, encoding = encoding, skipNul = skipNul)
nlines <- length(data[[which.max(keep)]])
if (cols != length(data)) {
warning("cols = ", cols, " != length(data) = ", length(data),
domain = NA)
cols <- length(data)
}
if (is.logical(as.is)) {
as.is <- rep_len(as.is, cols)
}
else if (is.numeric(as.is)) {
if (any(as.is < 1 | as.is > cols))
stop("invalid numeric 'as.is' expression")
i <- rep.int(FALSE, cols)
i[as.is] <- TRUE
as.is <- i
}
else if (is.character(as.is)) {
i <- match(as.is, col.names, 0L)
if (any(i <= 0L))
warning("not all columns named in 'as.is' exist")
i <- i[i > 0L]
as.is <- rep.int(FALSE, cols)
as.is[i] <- TRUE
}
else if (length(as.is) != cols)
stop(gettextf("'as.is' has the wrong length %d  != cols = %d",
length(as.is), cols), domain = NA)
do <- keep & !known
if (rlabp)
do[1L] <- FALSE
for (i in (1L:cols)[do]) {
data[[i]] <- if (is.na(colClasses[i]))
type.convert(data[[i]], as.is = as.is[i], dec = dec,
numerals = numerals, na.strings = character(0L))
else if (colClasses[i] == "factor")
as.factor(data[[i]])
else if (colClasses[i] == "Date")
as.Date(data[[i]])
else if (colClasses[i] == "POSIXct")
as.POSIXct(data[[i]])
else methods::as(data[[i]], colClasses[i])
}
compactRN <- TRUE
if (missing(row.names)) {
if (rlabp) {
row.names <- data[[1L]]
data <- data[-1L]
keep <- keep[-1L]
compactRN <- FALSE
}
else row.names <- .set_row_names(as.integer(nlines))
}
else if (is.null(row.names)) {
row.names <- .set_row_names(as.integer(nlines))
}
else if (is.character(row.names)) {
compactRN <- FALSE
if (length(row.names) == 1L) {
rowvar <- (1L:cols)[match(col.names, row.names,
0L) == 1L]
row.names <- data[[rowvar]]
data <- data[-rowvar]
keep <- keep[-rowvar]
}
}
else if (is.numeric(row.names) && length(row.names) == 1L) {
compactRN <- FALSE
rlabp <- row.names
row.names <- data[[rlabp]]
data <- data[-rlabp]
keep <- keep[-rlabp]
}
else stop("invalid 'row.names' specification")
data <- data[keep]
if (is.object(row.names) || !(is.integer(row.names)))
row.names <- as.character(row.names)
if (!compactRN) {
if (length(row.names) != nlines)
stop("invalid 'row.names' length")
if (anyDuplicated(row.names))
stop("duplicate 'row.names' are not allowed")
if (anyNA(row.names))
stop("missing values in 'row.names' are not allowed")
}
class(data) <- "data.frame"
attr(data, "row.names") <- row.names
data
}
ass_name <- list_of_config[["first_row"]]
Q
# (c) 2020 Peter Gruber and Paolo Montemurro
# Universita della Svizzera italiana
# Contact: peter.gruber@usi.ch - montep@usi.ch
# Libraries
library(evaluate)
library(stringr)
# Load functions
source("load_text.R")        # Used both from parse_config and shortcuts
source("parse_config.R")     # Make computer readable the instruction of config.txt
source("run_code.R")         # Rune the code in a separate environment
source("shortcuts.R")        # Fancy shortcuts for the tests!
source("do_assessment.R")    # Modify all_tests with tests results
source("create_feedback.R")  # From the test results, create the feedback
source("categorize_error.R") # Creates the error message for compiling or syntax error by run_code
# Parameters always valid
text_params     <- read.csv(file = "text_params.csv", head = TRUE, sep=",", row.names = 1, stringsAsFactors = F)
ass_title       <- load_text("config.txt")$first_row
ass_title       <- paste0("..",.Platform$file.sep,"submission",.Platform$file.sep, ass_title)
config_name     <- "config.txt"
solution_name   <- "solution.R"
### For being able to call grader() as a function, submission and solution must be global variables.
run_submission <- run_code(ass_title) # Run the submission in a separate environment and save it.
submission     <- run_submission$run_env
run_solution   <- run_code(solution_name)# Run the solution in a separate environment and save it
solution       <- run_solution$run_env
grade <- function(csv=TRUE,txt=FALSE,json=FALSE,normalize=TRUE,show_test=TRUE){
# Determine the tests
all_tests      <- parse_config(file_name = config_name, normalize=normalize)
# Assess the results of the tests
all_tests_res  <- do_assessment(all_tests, ass_title)
# Create feedback
feedback <- create_feedback(all_tests_res, csv=csv, txt=txt, json=json)
return(feedback)
}
grade()
file_name = "config.txt"
# Parse txt file
list_of_config <- load_text(file_name)
tests    <- list_of_config[["no_comment_text"]]
ass_name <- list_of_config[["first_row"]]
# Rileva esercizi
test_delimiter <- which(apply(tests, 1, function(r) any(r %in% c("---"))))
n_tests        <- length(test_delimiter)-1
# List of all_tests: enclose each exercise and save it
all_tests <- list()
score_vec <- NULL
for(i in 1:n_tests){
single_test              <- tests[(test_delimiter[i]+1) : (test_delimiter[i+1]-1) ,1]
single_test              <- data.frame(value = single_test, type=NA, stringsAsFactors = F)
prep_lines_bool          <- grepl("@",single_test$value)             # check if there are preparatory lines
prep_lines_num           <- sum(prep_lines_bool)                     # save number of them
single_test$value        <- str_replace(single_test$value, "@", "")  # delete the preparatory symbols...
# Naming each exercise type
single_test[1,"type"]                   <- "title"
single_test[prep_lines_bool, "type"]    <- "preparatory"
single_test[(2+prep_lines_num), "type"] <- "test"
single_test[(3+prep_lines_num), "type"] <- "max_score"
if(length(single_test$value) == (3+prep_lines_num)){single_test[nrow(single_test) + 1,] <- c(text_params["feedback_negative",],"negative_feed")}else{single_test[(4+prep_lines_num), "type"] <- "negative_feed"}
if(length(single_test$value) == (4+prep_lines_num)){single_test[nrow(single_test) + 1,] <- c(text_params["feedback_positive",],"positive_feed")}else{single_test[(5+prep_lines_num), "type"] <- "positive_feed"}
all_tests <- append(all_tests, list(single_test))
score_vec <- c(score_vec, as.numeric(single_test[single_test$type=="max_score","value"])) # saving each score for normalization...
}
if(normalize){
# Points must sum up to 100 (normalization)
weights <- round(score_vec/sum(score_vec) *100,1)
if(sum(weights)!=100){
weights[n_tests] <- weights[n_tests] - sum(weights) +100
for(i in 1:n_tests){  all_tests[[i]][all_tests[[i]]["type"]=="max_score","value"] <- weights[i]  }
}
}
# Points must sum up to 100 (normalization)
weights <- round(score_vec/sum(score_vec) *100,1)
weights
library(shiny)
# Define UI for data upload app ----
ui <- fluidPage(
titlePanel("Welcome to Autograder 2.0"),
sidebarLayout(
sidebarPanel(
fileInput("file_uploaded", "Upload your submission", multiple = FALSE),
actionButton("do_grading",label = "Grade")
),
# Main panel for displaying outputs ----
mainPanel(
textOutput("execution_time"),
textOutput("execution"),
tableOutput("result"),
textOutput("total_score")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
uploaded_file <- "impossiblefile"
# Load the file and copy it in the submission folder
Reactive_Var <- eventReactive(input$file_uploaded, {
uploaded_file <- paste0("..",.Platform$file.sep,"submission",.Platform$file.sep, input$file_uploaded$name) # Remember the name!!!
file.copy(input$file_uploaded$datapath, uploaded_file )
return(uploaded_file)
}) # difference between reactive and observe: https://stackoverflow.com/questions/53016404/advantages-of-reactive-vs-observe-vs-observeevent
observeEvent(input$do_grading,{
uploaded_file <- Reactive_Var()
# If the file is copied correctly
if(file.exists(uploaded_file)){
start     <- Sys.time()
source("grader.R")
grade()
execution_time <- paste0(round(Sys.time() - start,4)," seconds")
# create grade report (like a function...)
grade_report <- eventReactive(input$do_grading, { return(TRUE) })
if(grade_report()){ # If we pressed grade
output$execution_time <- renderText(paste0("Execution time:" , execution_time))
output$execution      <- renderText(paste("Execution errors:", run_submission$run_error_feedback))
output$result         <- renderTable(grade(csv=TRUE,txt=FALSE,json=FALSE,normalize=TRUE,show_test=TRUE))
}
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
my_cmd    <- paste0("ls ..",.Platform$file.sep,"submission")
my_cmd
student_filename <- system(my_cmd,intern = TRUE)
library(shiny)
# Define UI for data upload app ----
ui <- fluidPage(
titlePanel("Welcome to Autograder 2.0"),
sidebarLayout(
sidebarPanel(
fileInput("file_uploaded", "Upload your submission", multiple = FALSE),
actionButton("do_grading",label = "Grade")
),
# Main panel for displaying outputs ----
mainPanel(
textOutput("execution_time"),
textOutput("execution"),
tableOutput("result"),
textOutput("total_score")
)
)
)
# Define server logic to read selected file ----
server <- function(input, output) {
uploaded_file <- "impossiblefile"
# Load the file and copy it in the submission folder
Reactive_Var <- eventReactive(input$file_uploaded, {
uploaded_file <- paste0("..",.Platform$file.sep,"submission",.Platform$file.sep, input$file_uploaded$name) # Remember the name!!!
file.copy(input$file_uploaded$datapath, uploaded_file )
return(uploaded_file)
}) # difference between reactive and observe: https://stackoverflow.com/questions/53016404/advantages-of-reactive-vs-observe-vs-observeevent
observeEvent(input$do_grading,{
uploaded_file <- Reactive_Var()
# If the file is copied correctly
if(file.exists(uploaded_file)){
start     <- Sys.time()
source("grader.R")
grade()
execution_time <- paste0(round(Sys.time() - start,4)," seconds")
# create grade report (like a function...)
grade_report <- eventReactive(input$do_grading, { return(TRUE) })
if(grade_report()){ # If we pressed grade
output$execution_time <- renderText(paste0("Execution time:" , execution_time))
output$execution      <- renderText(paste("Execution errors:", run_submission$run_error_feedback))
output$result         <- renderTable(grade(csv=TRUE,txt=FALSE,json=FALSE,normalize=TRUE,show_test=TRUE))
}
}
})
}
# Create Shiny app ----
shinyApp(ui, server)
